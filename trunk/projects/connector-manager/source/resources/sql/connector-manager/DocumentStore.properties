## JdbcStore SQL localization resources.  This is used to tailor the
## SQL queries and DDL used by LocalDocumentStore to specific vendor
## implementations.

## SQL Table and Column names

# The name of the Connector Instance table that is created.
table.name = google_documents

# Note that the names of most of these columns are actually specified in
# com.google.enterprise.connector.SpiConstants.PERSISTABLE_ATTRIBUTES
# so they should not be modified here.

# SQL Timestamp stamps each addition to the table.
column.timestamp = timestamp

# The connector name.  A string with maximum length of 64 characters.
column.connector_name = connector_name

# The ID of the Feed file that contains the document. A string of 32 characters.
column.feed_id = feedid

# The snapshot ID.  TODO: SHOULD THIS BE AN INTEGER or a 16 Character string?
column.snapshot_id = snapshot

# The action applied to the document.
# A string of 8 characters such as ADD, DELETE, SKIPPED.
column.action = action

# The ID of the Document.
column.doc_id = docid

# The parent folder name for the Document.
column.parent_id = folderparent

# The container for the Document
column.container = container

# A message associated with the document action.  For instance, if the
# document is skipped for some reason, the message should indicate the reason.
column.message = message

# Arbitary custom value associated with the document.
column.custom1 = custom1
column.custom2 = custom2


## DDL Data Definitions

# The DDL statement is used to create the LocalDocumentStore
# table if it does not already exist.  Table creation and datatype syntax
# varies by database vendor.  The DDL may consist of several statements,
# so the DDL is specified as an EProperties list, where each list item
# is a separate SQL statement.
table.create.ddl = ( "CREATE TABLE IF NOT EXISTS ${table.name} ( ${column.timestamp} TIMESTAMP, ${column.connector_name} VARCHAR(64) NOT NULL, ${column.feed_id} VARCHAR(32), ${column.snapshot_id} VARCHAR(16), ${column.action} VARCHAR(8), ${column.doc_id} VARCHAR NOT NULL, ${column.parent_id} VARCHAR, ${column.container} VARCHAR, ${column.message} VARCHAR, ${column.custom1} VARCHAR, ${column.custom2} VARCHAR, PRIMARY KEY ( ${column.connector_name}, ${column.doc_id} ) )" )

## Queries
# The queries in PreparedStatement syntax, so the order of the parameters
# must not be altered, since substitution is by parameter index, not name.

# The columns returns by the Document queries.
# The statement is in PreparedStatement syntax, so the order of the parameters
# must not be altered, since substitution is by parameter index, not name.
document.columns = "${column.timestamp}, ${column.connector_name}, ${column.feed_id}, ${column.snapshot_id}, ${column.action}, ${column.doc_id}, ${column.parent_id}, ${column.container}, ${column.message}, ${column.custom1}, ${column.custom2}"

# Query returns a Document by ID.
single.document.query = "SELECT ${document.columns} FROM ${table.name} WHERE ( ${column.connector_name} = ? AND ${column.doc_id} = ? )"


# Query returns all Documents for a Connector with ID greater than the supplied ID.
all.documents.after.id.query = "SELECT ${document.columns} FROM ${table.name} WHERE ( ${column.connector_name} = ? AND ${column.doc_id} > ? ) ORDER BY ${column.doc_id}"

# Query returns all Documents in a list.
# This query uses java.text.MessageFormat syntax, rather than PreparedStatement
# syntax because PreparedStatements may not contain and arbitrarily long list.
batch.documents.query = "SELECT ${document.columns} FROM ${table.name} WHERE ( ${column.connector_name} = {0} AND ${column.doc_id} IN ( {1} ) )"

# Delete all rows for the named connector.
delete.connector = "DELETE FROM ${table.name} WHERE ( ${column.connector_name} = ? )"