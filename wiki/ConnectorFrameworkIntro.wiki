The *Google Connector Framework (GCF)*  is an open-source Java framework that enables
Google search appliances to present content stored in various popular *Enterprise Content
Management (ECM)* systems.

*Change History*

29 Nov 2006 First Draft (dmz/ns) Two-pager & outline

12 Dec 2006 Draft 1.0d1 (jwp) Expanded outline & first draft

15 Dec 2006 Draft 1.0a1 (jwp) Edits per 12-14 team meeting

18 Dec 2006 Draft 1.0a2 (jwp) Move to Wiki, revise arch diagram


= Google Connector Framework Technical Introduction=

*Draft 1.0a2*

*Revised 18 Dec 2006 (jwp)*

The *Google Connector Framework (GCF)* enables Google search appliances to work with
content stored in various popular Enterprise Content Management systems. An *Enterprise
Content Management (ECM)* system provides a central repository for large numbers of
documents; it is not uncommon for such systems to manage ten million documents. While all
ECM systems provide some ability to retrieve documents based on associated keywords or
other metadata, this functionality is extremely limited and slow in comparison to the
powerful, flexible search capabilities that Google search appliances provide.

Many ECM systems provide an API that enables the programmatic manipulation of the ECM
repository. You can use the Connector Framework to create your own Java connector that
calls the native API of a specific ECM system on behalf of Google search appliances.
Multiple connector instances enable a search appliance to interact with multiple ECM systems.

Most ECM systems authenticate users, control access to documents, and provide
version-management functionality. Each connector enables a Google search appliance to
provide customized, optimized, automatic interaction with the authentication and
authorization features of a specific ECM system in order to:

    * Build and update the index of searchable documents

    * Customize search results according to the access privileges of the user that issued
the search query

    * Serve documents from the ECM repository when the user clicks links in the search results
    * Provide a single-sign-on experience that allows users to log into the search
appliance and the ECM system only once per day, rather than every time the user issues a
query or clicks a link in search results


Many ECM systems provide a means of signalling users when documents are added, deleted, or
changed. Your Java connector can use events generated by the ECM system to keep its index
of crawled documents up-to-date. However, the Connector Framework does not require the ECM
system to generate events. If the file paths that the Google search appliance uses to
crawl the document repository are not suitable for direct access to the document by users,
your connector can represent them differently in search results.

The Google Connector Framework (GCF) introduces one new significant public component, the
Connector Manager. This service is responsible for hosting and running connectors built
with this framework. It also manages all communications between Google search appliances
and connectors. To manage your connectors, you'll run an instance of the Connector Manager
on any application server that provides a servlet interface, such as Apache Tomcat.  

The Google Connector Framework (GCF) also provides:

    * A simple and consistent graphical user interface (GUI) for administration of connectors.

The Administration console of the Google search appliance provides a graphical user
interface for configuring and managing connectors. Using the Connector Framework, you can
customize and extend this interface to accommodate specific features of your own connectors.

    * Programmatic configuration of connectors by means of Spring-compliant XML files.

For ease of installation, you can use a Spring file to

    * Automate the configuration of all connector settings
    * Configure optional features that do not lend themselves well to representation in a
graphical interface
    * Specify configuration details not visible to the connector, such as the hostname of
the machine on which its Connector Manager instance runs

    * Common scheduling and reporting that is customizable for each connector instance.

The GSA console provides centralized scheduling and reporting for all installed
connectors, and you can configure individual connectors to augment or supersede these
settings. You can customize your connector's crawling, feeding, authentication, and
authorization behavior for optimum interaction with a specific ECM system. Additionally,
you can configure each individual connector instance for optimum support of
installation-specific parameters, such as the maximum number of requests it may send to a
particular document repository in a specified time period.

    * Open source code

Google uses the Apache 2 license to make the Connector Framework source code open.
Google's goals in making the project open-source are:

    * To encourage and facilitate the development of connectors and other custom code for
the GSA

    * To provide the ultimately authoritative documentation of system behavior: source code.
    * To allow developers to debug with the aid of full view of the source
    * To open the architecture and development of the framework as a cooperative project
    * To give developers freedom to fix bugs in the framework
    * To enable developers to add significant new features easily
    * To encourage the free exchange of features, fixes, and other ideas within the
developer community


Although Google is providing the first release of this framework, it's important to note
that Google does not officially provide technical support for the Connector Framework; as
with any other open-source project, technical support, bug fixes, and new features for
this framework come from your fellow members of the open-source community.

Please note also that this version of the Connector Framework does not yet provide full
functionality. Rather, it provides an early peek at this project for those who wish to get
an early start on the design and development of their own connectors. Google urges you to
return to this site regularly for updates to the connector framework source code and its
documentation.

 Architectural Overview
<!-- This section is very rough. For today, I just want to get the ideas down - I'll
polish them up later. For this section only, pls concentrate on technical accuracy, not
grammar or organization. Thanks! (jwp) -->

A specific connector instance communicates with a specific ECM system in response to
requests it receives from its Connector Manager. This Connector Manager runs on an
application server and communicates with the servlet interface of another Connector
Manager instance onboard the Google search appliance. Each connector instance manages
exactly one ECM system, but the ECM system can manage multiple repositories. The use of an
off-board authentication (AuthN) server is required for Single-Sign On functionality;
otherwise, it is optional.

You can see a diagram of the Connector Framework architecture at 
"http://docs.google.com/Doc?id=w.dgnhd83_20m6tkjd"

<!-- I still haven't figured out how to arrange thngs so the lines running from the
servlet intf to the connectors don't cross the lines running from the connectors to the ECMs.
Do we need to show the user's browser?-->


A single .jar file contains the executable code and resources required to create a
connector instance. To install this file, you place it in a designated directory on an
application server that runs a Connector Manager instance. The administrator of the Google
search appliance specifies the location of this special directory when configuring the
Connector Manager instance that runs on the application server.

When you run your Connector Manager instance, you must first register it with the Google
search appliance, which causes it to appear in the Admin Console of the Google search
appliance. Each Connector Manager instance discovers all connector JARs in its special
directory automatically, and displays a list of them in the Admin Console.

To create an instance of a connector, you choose it from the drop-down list that a
Connector Manager instance displays in the Admin Console, then click the Create New
button. The Admin Console displays the new connector instance along with the additional
user interface items required to configure it; for example, each connector instance
configuration page must provide a means of specifiying the path to the ECM system that
particular connector instance manages. Connector-specific user interface items are HTML
form snippets that the connector .jar file provides. 

Crawling and Feeding

To generate the initial index of repository content,  the search appliance sends requests
to the connector via the Connector Manager, as scheduled in the Admin Console. In response
to these requests, the connector log into the ECM repository as a super-user that can read
all documents, and calls the existing Google Crawl API. Updates to the index are handled
similarly, using the existing Feed API.

Authentication and SSO

When a user searches the ECM repository, the search results must display only documents
the ECM system allows that user to see. To do so, the Connector Manager must authenticate
and authorize (AAA) the user on behalf of the ECM system before serving the results of the
query. The AAA mechanism is installation-specific; for example, a simple installation
might utilize the built-in HTTP Basic authentication functionality that the Google search
appliance provides, but most corporate intranets will utilize some sort of off-board
identity provider, such as an LDAP or SAML server, for this purpose. Google strongly
recommends the use of a third-party identity provider, as your connector's implementation
of a single-sign on (SSO) user experience is dependent on the use of one.

In the absence of the SSO experience, the user is challenged for credentials under the
following circumstances:

    * initial login to the ECM in the course of conducting a search
    * every time the user clicks a search-results link to a document in the ECM repository
    * initial login to the ECM separately from Google searches


A connector that implements SSO functionality eliminates the second bullet point entirely,
with the result that the ECM system challenges the user for AAA credentials only once per
day, as opposed to every time the user searches or clicks a link in search results.
Unfortunately, there is nothing your connector can do to extend the SSO experience to the
ECM system itself if that system does not support the use of SSO on its own. With the SSO
experience in place, the user gets challenged only twice per day: once when the connector
conducts its the first search of the day on behalf of that user, and once when the user
logs into the ECM system directly (to add a new document to the repository, for example.)

To implement the SSO experience, your connector authenticates to the external identity
provider on behalf of the user when the user conducts the first search of the day. The
identity provider returns a Web cookie that the components of the system use subsequently
for AAA purposes. The details of this mechanism are complex and require more substantive
discussion than this document can provide; in brief, the sequence of events that occurs
when a user attempts to search ECM repository content using the Google search appliance is
as follows:

   1. On search, user's browser contacts the Google search appliance to open a session
   2. The search appliance displays a username/password login page
   3. The search appliance passes the user's login info to the connector manager's servlet
interface
   4. The servlet interface passes user login info to the Security API of the Connector
Manager instance
   5. The Connector Manager instance passes the user's login info to the identity provider
   6. The identity provider returns to the Autnentication API a cookie that AAAs the
Connector Manager as that user for subsequent interactions with the ECM system
   7. The Connector Manager passes the cookie back to the search appliance via the servlet
interface
   8. The search appliance implants the cookie in the user's browser.
   9. User clicks on a link in the search results.
  10. The ECM system treats the user as already having logged in, and serves the document
without a second challenge for user credentials.


As mentioned previously, this summary omits many details in the interest of brevity; in
particular, watch this site for a more substantive discussion of how to manage the cookie
and the search results in order to make this scenario work.

Authorization
Recall that the search appliance logs into the ECM system as a super-user when building or
updating its index of documents in the ECM repository. Because most users do not have
unlimited access to all documents in the repository, a connector usually must also filter
search results according to the access privileges associated with the user that issued the
search query. 

When an authenticated user issues a search query, the following sequence of events occurs:

   1. The search appliance returns to the Connector Manager a list of all documents
matching the query.
   2. The Connector Manager distributes the list items to each connector according to the
ECM system or repository the connector manages; each connector gets a list of only the
documents that reside in the ECM system or repository it manages.
   3. The connector calls the native API of the ECM system to test the user's access
privileges for each document; for best performance, this test validates documents in
batches rather than with individual calls.
   4. The connector returns to the Connector Manager only the documents that the ECM
system allows the user to access.
   5. The connector manager aggregates the results from all connectors and returns those
results to the search appliance.
   6. The search appliance serves the list of results to the user.


Please visit this site again for documentation updates that describe these concepts and
behaviors in greater detail.

System Requirements
This section describes the systems you'll need for connector development:

    * ECM System: the Enterprise Content Management system that holds the documents to search
    * Connector Host: the computer on which the Connector Manager and its connectors run
    * Development System: the computer you use to write and compile Java code




ECM System

Because the Connector Framework is intended for connections with ECM systems, it assumes
that the content source:

    * Manages file-based data.

Ideally, these files are text-based, but search results can present other kinds of files
if the ECM metadata provides a text-based alternate representation of the document.

    * Provides the following metadata items for all documents that are to be indexed:
          o last modify date
          o a system-dependent unique ID
    * Has a central document registry that can be queried efficiently for documents added
or changed after a specified date and time.
    * Can return documents in modify-date order.


An external system that does not meet these assumptions may not interoperate easily with
the current framework.
Connector Host System
You can run the Connector Manager and your connectors on any platform that provides:

    * Java language version 1.4.2
    * Java runtime environment version 1.4 or above
    * An application server that has a servlet interface.

Google uses Apache Tomcat for development of this framework; however, any similar
application server should be suitable. Should you run into incompatibilities, the open
source code base allows you to customize the framework or your implementation to support
your preferred Connector Host system.

Development System
You can develop in this framework using any Java environment that supports Java
Development Kit (JDK) version 1.4.2 and Java Runtime Environment version 1.4 or later. For
your convenience, this site provides sample projects and configuration files for the
Eclipse environment.

Connector Development Overview
There are five main steps to developing a connector:

   1. Design : mapping your design goals and ECM system characteristics to features of the
CM Framework
   2. Coding : implementing required content-feed, authentication, authorization, crawl,
and search functionality; building your connector jar
   3. Installation : uploading your built connector's .jar file to the Connector Host system
   4. Configuration : Configuring Connector Manager and connector settings; running the
Connector Manager and the connector
   5. Test and Debug : Creating your own unit tests, invoking unit tests the connector
framework provides, troubleshooting suggestions.


The built connector is a single .jar file that provides executable code and resources.
These resources include the Spring-compliant XML file that specifies configuration
information.
 To install and run a new connector, you'll take the following steps:

   1. Place the connector's .jar file in a location specified when the Connector Manager
was installed.
   2. In the Admin Console of the Google search appliance, configure and run the new
connector.

For security reasons, a connector cannot run itself. A connector that is entirely
self-configuring still requires the intervention of the administrator of the Connector
Manager to run.

Connector Configuration Using Spring
Spring is a Java framework that provides, among other things, a means of using XML files
to manage the configuration of connectors through an approach known as Dependency
Injection; essentially, your connector configures itself at runtime using objects the
Spring framework provides according to information its XML configuration file specifies.
While this statement is accurate, it is similar to saying that a rocket, a bird, and a
biplane are things that fly; it skips over many details in the interest of brevity. For
more information on Spring, see the Introduction to the Spring Framework article, by Rod
Johnson. On the site that hosts this article, http://theserverside.com , you'll find
numerous resources dedicated to the Enterprise Java Community.

Getting Started
Although the current release of the framework does not yet provide complete functionality,
you can still use the current framework to begin your development efforts. This section
describes steps you can take right now to get started on the design and development of a
connector . Please return to this site regularly for updates to the framework and
documentation.

Downloading the Connector Framework Distribution
This site provides pre-release versions of the Connector Framework source code and Javadoc
API reference. At the present time, you'll need to use Subversion (a popular open-source
version control system) to download them; later on, you'll be able to browse the framework
source code and documentation online by clicking on the Source tab of this site.

To get Subversion, click here to go to the home page of the Subversion project web site,
where you can find prebuilt and build-your-own versions of this utility for many operating
systems.
 
Once you've installed Subversion, follow the instructions on this page to download the
Connector Framework sources.

For more information, read Version Control With Subversion, a free book by Ben
Collins-Sussman, Brian W. Fitzpatrick, and C. Michael Pilato.

Looking at the Sources
More complete documentation is on the way soon; for now, here are some pointers into the
source code:
<!--  this is off the top of my head, undoubtedly wrong, as I haven't even seen any code
at this point. But you get the idea. Specific suggestions appreciated, esp wrt which
interfaces they must implement in order to do what, and so on. (jwp) -->

    * One package, com.google.enterprise.connector.spi, provides the entire connector
framework.
    * You'll extend class ConnectorType to create your own connector class that provides
functionality and data that is common to all of your connectors.
    * You'll extend the Connector subclass of the ConnectorType class to add
connector-specific functionality, such as the details required to interoperate with a
specific ECM system. You instantiate the Connector subclass to create a connector instance.

For example, your MyConnectorType subclass might provide a MY_REPOSITORY variable that all
of your connectors use.  Your MyFooConnector subclass of the Connector class might cast
this variable to the MyFooType, while your MyBarConnector subclass might cast it to the
MyBarType. Additionally, each of these subclasses might add other data and methods that
instances of their particular kinds of connectors need in order to interoperate with a
particular ECM system; for example, perhaps the Bar ECM system and the Foo ECM system use
different metadata models.

    * The Connector Manager instance that runs your connector comprises three objects:
AuthenticationManager, AuthorizationManager, and QueryTraversalManager. You'll extend the
first two classes to call the native API your ECM system provides for authentication and
authorization services. Your subclass of the QueryTraversalManager class implements your
connector's crawl and feed functionality by calling the existing Google crawl and feed APIs.
    * The SimpleXXX and ValueXXX classes provide typed data objects used to pass data
among the various components of the system, as well as getters and setters for
manipulating the data those objects encapsulate. Again, you can extend these classes as
necessary to manipulate your own connector-specific data.
    * Most of the remaining objects have self-documenting names; for more summary info,
see the Use view of the Javadoc reference to the connector framework.

<!-- these particular javadocs are in max's home directory; update this link when they are
browsable on code.google.com -->
 

Setting Up
You do not need a Google search appliance to begin development of your connector. However,
you do need to create an isolated network that you can use to test development versions of
your connector. This testing network must provide a connector host machine and an ECM
system. You'll also need a way to transfer a .jar file from your development system to the
Connector Manager host machine on the testing network.

Without the full implemenation of the connector manager, you can implement crawling,
feeding, and query functionality. At present, the only way to configure a connector is by
means of its Spring file, as the Google search appliance that provides a user interface
for administration of connectors is not yet available. Again, return to this site
regularly for updated information.

Background Knowledge
Before attempting to design your connector, you should be familiar with the following:

    * You should understand the use of cookies by Web services; in particular, you should
know how to implant a cookie in a Web browser and retrieve it.

    * You should be familiar with the basic concepts behind ECM systems.

    * You must have strong experience with the specific ECM system for which you intend to
create a Java connector. In particular, you need to have hands-on understanding of the API
your ECM system provides for:

    * authenticating its users
    * authorizing user access to documents
    * single-sign-on (if applicable; not all ECM systems provide single-sign-on functionality)
    * retrieving documents by query


    * You'll also need to understand how Google search appliances work; in particular, the
APIs Google provides for calling the crawl and feed mechanisms.


    * Google recommends strongly that your connector implement Single Sign-On
functionality; to do so, you'll need to make use of a use a network-based identity
provider (such as SAML, LDAP, Netegrity, or another such solution.)


Community
A vast community of Java developers ready to communicate and collaborate with you is just
a click away. This section presents links to information and resources that may be useful
in your connector-development endeavors.

Discussion

<!-- placeholder for link to our own connector discussion forum -->

Tools

http://subversion.tigris.org
Home page of the Subversion project web site

http://eclipse.org
Downloads, discussion, and resources for users of the Eclipse open-source Java IDE

Resources

http://theserverside.com
White papers, news, forums, and other resources for the Enterprise Java Community,
including the Introduction to the Spring Framework article, by Rod Johnson.